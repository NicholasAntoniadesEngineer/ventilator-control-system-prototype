
//---------------------------------------------------------------------------------------------------------------------------
//   Project  : Ventilator control system
//   File     : TMCL_driver.tmc
//   Brief    : Source code for  the TMCL driver controlling the stepper motor
//   Author   : Nicholas Antoniades
//---------------------------------------------------------------------------------------------------------------------------



//---------------------------------------------------------------------------------------------------------------------------
// *** Set Global Paramater(SGP) setting user global variables values to be stored in EEPROM *** //
// SGP <Paramater 0..55 55..255>, <bank 0 ..3> , <value>
// Paramater numbers correlate to memory address of the specified memory bank
// Memory bank 0 is for Global configuration of the device
// Memory bank 1 is not used
// Memory bank 2 is for user defined variables
// Memory bank 3 is for interrupt configuration

// *** Setting symbolic names for global variables*** //
state = 0				//system current state
vInsp = 1 			//inspiration velocity
vExsp = 2				//expiration velocity
amax = 3				//max acceleration
cmax = 4         		//max current 0..256
dmax = 5				//max deceleration
posInspiration = 6		//inhaltion position
posExpiration = 7		//exhalation position
cycleStage = 8	 	//indicator of the current cycle stage

flatplate = 45000
dome = 38000

SGP state, 2, 0
SGP vInsp, 2, 20000
SGP vExsp, 2, 25000
SGP amax, 2, 7629278
SGP cmax, 2, 200
SGP dmax, 2, 7629278
SGP posInspiration, 2, 0
SGP posExpiration, 2, -dome
SGP cycleStage, 2, 0
//---------------------------------------------------------------------------------------------------------------------------


//---------------------------------------------------------------------------------------------------------------------------
// *** Store Global Paramater(STGP) storing user global variables in EEPROM *** //
// STGP  <Paramater 0..55 55..255>, <bank 0 ..3>
// This command is used to store global parameters permanently in the EEPROM.
// The contents of the user variables can either be automatically or manually restored at power on.

STGP state, 2
STGP vInsp, 2 
STGP vExsp, 2 
STGP amax, 2 
STGP cmax, 2 
STGP dmax, 2 
STGP posInspiration, 2 
STGP posExpiration, 2 
STGP cycleStage, 2
//---------------------------------------------------------------------------------------------------------------------------


//---------------------------------------------------------------------------------------------------------------------------
// *** Setting axis paramaters based on global variables *** //
// *** Get Global Paramater(GGP) into the accumulator register
// GGP <parameter number>, <bank>
// *** Accumulator Access Paramater(AAP) Push the contents of the accumulator into the specified axis paramater
// AAP <parameter number>, <motor number>
// *** Accumulator Global Paramater(AGP) Push the content of the accumulaator into the specified global parameter
// AGP <paramater number>, <bank number>
// *** Accumulator Coordinate(ACO) Copies the value of the accumulator to a selected coordinate
// ACO <coordinate number 0..20>, <motor number>

GGP vExsp, 2			//fetch vInsp
AAP 4, 0  			//set vInsp
GGP amax, 2			//fetch amax
AAP 5, 0	 			//set amax 
GGP cmax, 2			//fetch cmax
AAP 6, 0  			//set cmax
GGP dmax, 2 			//fetch dmax 
AAP 17,0  			//set dmax
GGP posInspiration,2   //fetch posInspiration
ACO 1, 0				//set coordinate for position 0
GGP posExpiration, 2   //fetch posExpiration
ACO 2, 0				//set coordinate for position 1
//---------------------------------------------------------------------------------------------------------------------------


//---------------------------------------------------------------------------------------------------------------------------
// *** Initialising axis paramaters *** /
// *** Set Axis Paramater(SAP) Sets the axis paramater of the chosen axis to the desired value.
// SAP <paramater number>, <axis, ..set this to one for our single motor set up..>, <value>
// *** Set Global Paramater(SGP) Set the global paramater in the indicated memory banke to the desired value.
// SGP <paramater number>, <bank>, <value>

SAP 1,0, 0 	    			//set actual position to zero
SAP 16, 0, 0    			//disable first acceleration/deceleration phase for position control ramps 
SGP 77, 0, 1				//start code on start up, set to 0 to set default to off  
//---------------------------------------------------------------------------------------------------------------------------


//---------------------------------------------------------------------------------------------------------------------------
// *** Set Output(SIO) Set the state of the GPIO pins.
// SIO <port number>, <bank number>, <value>
// SIO 0, 2, 1 (Set OUT0 to high)
// SIO 0, 0, 0 All pull-up resistors off.
// SIO 0, 0, 1 Pull-up resistor on for IN0/HOME.Pull-up resistors off for IN1/IN2.
// SIO 0, 0, 2 Pull-up resistor off for IN0/HOME.Pull-up resistors on for IN1/IN2.
// SIO 0, 0, 3 All pull-up resistors on.
//
// *** Get Input/Output (GIO) The status if the GPIO can be read out into the accumulator
// GIO <port number>, <bank number>    
// Bank 0 = Digital inputs (Pin 2) GIO 0, 0
//                         (Pin 3) GIO 1, 0
//                         (Pin 4) GIO 2, 0
//          Optically isolated inputs(Pin 5) GIO 3, 0
//                                   (Pin 6) GIO 4, 0
//
// Bank 1 = Analog inputs (Pin 2)   GIO 0, 1 (range 0..4095)
//                        (voltage) GIO 8,1 (Read back supply voltage in x100mV, e.g. a value of 240 means 24V DC)
//                        (Temp)    GIO 9,1 (deg C)
//
// Bank 2 = States of digital outputs (Pin 8) GPIO 0, 2 (range 0/1)

//---------------------------------------------------------------------------------------------------------------------------

// *** Jump Conditional(JC) Allows for a conditional jump to a fixed address. 
// The condition refers to the ersult of a preceding comparison
// 0 - ZE - zero
// 1 - NZ - not zero
// ... check the manual ..
// *** Call Subroutine (CSUB) 
// *** Compare (COMP) The specified number is compared to the value in the accumulator register.
// The result of the comparison can be used for the JC instruction

//---------------------------------------------------------------------------------------------------------------------------
// *** stallGuard™ initialization *** //
stallGuardValue = 2  			//-64 = highest sensitivity ... 63 = lowest sensitivity

// *** stallGuard™ initialization *** //
SAP 173, 0, 1    				//set stallGuard™ filter disable
SAP 174, 0, stallGuardValue  	//stallGuard™ threshold
SAP 181, 0, 40000 				//min. speed for motor to be stopped by stallGuard™

// *** Interrupt initialization *** //
VECT 15, returnToZero 			//defines the interrupt vector for the stallGuard™ interrupt
EI 15 							//enable stall interrupt
EI 255 							//globally switch on interrupt processing


// *** Homing function** //
// Can customise the reference search speed


//state 0 is the homing state
state0:
	// Set limit switches off
	SAP 12, 0, 1         //disable right limit switch stop
	SAP 13, 0, 1         //disable left limit switch stop

	//setting up reference search
	SAP 193, 0, 65       //axis parameter, reference search mode, searches for right switch
	SAP 194, 0, 16000    //reference search speed
	SAP 195, 0, 14000    //reference switch speed
	RFS START, 0         //start reference search
	WAIT RFS, 0, 0       //wait until RFS is done or timeout happend
	SGP cycleStage, 2, 0 //set cycle stage to expiration	

	//state check loop
	loop0:
		//check for state 1
		GGP  state,2		//get the current value of state from memory
		comp 1				//does state = 1
		JC EQ, state1			//if state = 1, jump to state1
		JA loop0				//jump to the start of loop1

	JA state0



// *** State 0 Loop *** //
state1:

	// Through comms update:
	// 1. coordinates to update volume
	// 2. vInsp and vExsp to update frequencies
	// 3. state variable to update system state

	//do a state check

	//check for state 0
	GGP  state,2	//get the current value of state from memory
	comp 0			//does state = 0
	JC EQ, state0 	//if state = 0, jump to state0

	// Update coordinates based on values in memory
	GGP posInspiration,2  	//fetching posInspiration varirable from memory into acumulator register
	ACO 1, 0				//set coordinate for position 0 based on value in acumulator register
	GGP posExpiration, 2   //fetching posExpiration varirable from memory into acumulator register
	ACO 2, 0				//set coordinate for position 1 based on value in acumulator register

	// Inspiration part of cycle
	SGP cycleStage, 2, 1 //set cycle stage to inspiration
	GGP vInsp, 2		//fetch vmax variable from memory into acumulator register
	AAP 4, 0  	  	//update velocity based on value in acumulator register
	SIO 0, 2, 1		//set out0 high indicating Inspiration part of cycle
	MVP COORD, 0, 1   //turn motor to coordinate 1
	WAIT POS, 0, 0	//wait until position reached	
	
		//check for state 0
	GGP  state,2	     //get the current value of state from memory
	comp 0			//does state = 0
	JC EQ, state0 	//if state = 0, jump to state0

	// Expiration part of cycle
	SGP cycleStage, 2, 1 //set cycle stage to expiration
	GGP vExsp, 2		//fetch vmax variable from memory into acumulator register
	AAP 4, 0  	 	//update velocity based on value in acumulator 
	SIO 0, 2, 0		//set out0 high indicating Expiration part of cycle
	MVP COORD, 0, 2	//turn motor to coordinate 2
	WAIT POS, 0, 0	//wait until position reached

	JA state1 			//jump to the start of loop 0
//---------------------------------------------------------------------------------------------------------------------------

// *** begin (if-else-statement) *** //
state0Check:
	//check for state 0
	GGP  state,2	//get the current value of state from memory
	comp 0			//does state = 0
	JC EQ, state0 	//if state = 0, jump to state0
	RSUB 			//end of subroutine

state1Check:
	//check for state 1
	GGP  state,2		//get the current value of state from memory
	comp 1			//does state = 1
	JC EQ, state1		//if state = 1, jump to state1	
	RSUB 			//end of subroutine

// *** end (if-eslse-statement) *** //


//---------------------------------------------------------------------------------------------------------------------------
// *** Stall Guard interrupt functino** //
returnToZero:
	GGP  cycleStage,2	//get the current value of state from memory
	comp 0			//does cycle stage = 0 (insp)
	JC EQ, state0 	//if state = 0, jump to state0

	//RETI						//end of interrupt


//---------------------------------------------------------------------------------------------------------------------------